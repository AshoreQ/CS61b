你的世界要求如下：

1. 世界必须是使用我们的贴图引擎绘制的2D网格，tile引擎在lab5中描述过。

2. 世界必须是伪随机生成的。实验5将讨论伪随机性。

3. 生成的世界必须包含房间和走廊，尽管它也可能包含室外空间。

4. 至少有些房间应该是矩形的，尽管你也可以支持其他形状。

5. 你的游戏必须能够生成包含转弯的走廊(或者是交叉的直走廊)。

6. 这个世界应该包含随机数量的房间和走廊。

7. 房间和走廊的位置应该是随机的。

8. 房间的宽度和高度应该是随机的。

9. 走廊的长度应该是随机的。

10. 房间和走廊的墙壁必须与地板在视觉上截然不同。
墙壁和地板应该与未使用的空间在视觉上区分开来。

11. 世界应该每次都有本质上的不同，即你不应该拥有相同的基本布局，具有容易预测的功能。


作为一个满足所有这些要求的世界的例子(点击获取更高的分辨率)，请参阅下面的图像。
在这张图片中，#代表墙壁，一个点代表地板，还有一个金色的墙段代表一扇锁着的门。
所有未使用的空格都留空。

我们提供的tile渲染引擎接收一个TETile对象的2D数组，并将其绘制到屏幕上。
让我们暂时把这个叫做TETile[][] world。world[0][0] 对应于世界的左下角贴图。
第一个坐标是x坐标，例如，world[9][0]指的是从左下角瓷砖到右侧的第9块空间。
第二个坐标是y坐标，它的值随着我们向上移动而增加，例如，world[0][5]距离左下角的贴图5个贴图。
所有的值都应该是非空的，即确保在调用renderFrame之前将它们都填满。
确保你理解了世界网格的方向!
如果你不确定，可以写一些简短的示例程序来加深你的理解。
如果你搞混了x和y或者上下，调试的时候就会非常混乱。

我们在Tileset.java中提供了一小部分默认的瓦片，这应该是创建TETile对象的一个很好的例子。
我们强烈建议你也添加自己的瓷砖。


你的游戏必须支持启动它的两种方法，一种使用Core.Game.playwithkeyboard()方法，另一种使用Core.Game.playWithInputSting(String s)方法。
在运行方法Core.Game.playWithKeyboard()时，游戏必须显示一个主菜单，至少提供开始新游戏、加载之前保存的游戏和退出游戏的选项。
主菜单只能通过键盘导航，用N表示“新游戏”，用L表示“加载游戏”，用Q表示“退出”。你可以添加额外的选项。

在按下N选择“new game”后，应该提示用户输入一个“random seed”，这是他们选择的一个整数。
这个整数将用于随机生成世界(如稍后和实验5所述)。
在用户按下种子中的最终数字后，他们应该按S来告诉游戏他们已经输入了他们想要的整个种子。

“Load”命令的行为在本规范的其他地方有描述。

如果游戏从Core.Game.playWithInputString()开始，就不会显示菜单，也不会在屏幕上绘制任何东西。
否则，游戏应该使用Core.Game.playWithKeyboard()方法处理给定的字符串，就像人类玩家按下给定的键一样。
例如，如果我们调用Core.Game.playWithInputString("N3412S")，游戏应该生成一个带有种子3412的世界，并返回生成的2D tile数组。

我们建议你在项目的第二阶段(交互)之前不要实现Core.Game.playWithKeyboard()，不过你随时都可以实现它。
使用playWithInputString将更容易测试驱动和调试你的世界生成器。

如果你想让用户拥有额外的选项，例如选择角色属性的能力，指定世界生成参数等，你应该创建额外的选项。
例如，你可以在主菜单中添加第四个选项“S”，即“select creature and start new game”，如果你希望用户能够选择什么类型的生物进行游戏。
这些额外的选项可能具有您选择的任意行为。N、L和Q的行为必须与规范中描述的完全一致!




